# Legacy Command Compatibility Template

## Overview
This template ensures 100% backward compatibility for all existing APM commands while seamlessly integrating native Claude Code sub-agent capabilities.

## Configuration Variables
```yaml
# Legacy Compatibility Configuration
LEGACY_COMPATIBILITY_LEVEL: {{LEGACY_COMPATIBILITY_LEVEL}}  # full, enhanced, standard
COMMAND_PRESERVATION_MODE: {{COMMAND_PRESERVATION_MODE}}    # exact, enhanced, optimized
VOICE_INTEGRATION_LEVEL: {{VOICE_INTEGRATION_LEVEL}}        # full, partial, disabled
SESSION_MANAGEMENT_MODE: {{SESSION_MANAGEMENT_MODE}}        # classic, enhanced, hybrid
PERSONA_ACTIVATION_MODE: {{PERSONA_ACTIVATION_MODE}}        # traditional, enhanced, adaptive

# Enhancement Settings
PERFORMANCE_ENHANCEMENTS: {{PERFORMANCE_ENHANCEMENTS}}      # true, false
ERROR_HANDLING_IMPROVEMENTS: {{ERROR_HANDLING_IMPROVEMENTS}} # true, false
CONTEXT_PRESERVATION_UPGRADES: {{CONTEXT_PRESERVATION_UPGRADES}} # true, false
BACKWARD_COMPATIBILITY_TESTING: {{BACKWARD_COMPATIBILITY_TESTING}} # comprehensive, standard, basic
```

## Legacy APM Command Preservation

### 1. Core APM Commands
```markdown
## Complete APM Command Support

### Primary Commands (100% Preserved)
- `/ap` or `/ap_orchestrator` - AP Orchestrator activation
- `/analyst` - Analyst Agent activation  
- `/architect` - System Architect activation
- `/design-architect` - Design Architect activation
- `/dev` or `/developer` - Developer Agent activation
- `/pm` - Project Manager activation
- `/po` - Product Owner activation
- `/qa` - QA Agent activation  
- `/sm` - Scrum Master activation

### Session Management Commands (100% Preserved)
- `/handoff` - Agent handoff procedures
- `/switch` - Session compaction and switching
- `/wrap` - Session wrapping and archiving
- `/session-note-setup` - Session notes initialization

### Specialized Commands (100% Preserved)
- `/qa-framework` - QA Framework access
- `/qa-predict` - ML-powered prediction (92% accuracy)
- `/qa-optimize` - Test optimization (63% time reduction)  
- `/qa-anomaly` - Anomaly detection (94% precision)
- `/qa-insights` - AI-powered insights
- `/parallel-qa-framework` - Parallel QA execution
- `/parallel-sprint` - Parallel development orchestration
```

### 2. Command Recognition Engine
```bash
# Legacy Command Detection and Routing
detect_legacy_command() {
    local user_input="$1"
    
    # Exact command matching (preserved patterns)
    case "$user_input" in
        "/ap"|"/ap_orchestrator"|"ap"|"AP")
            route_to_legacy_orchestrator
            ;;
        "/analyst"|"analyst")
            route_to_legacy_analyst
            ;;
        "/architect"|"architect")  
            route_to_legacy_architect
            ;;
        "/design-architect"|"design architect")
            route_to_legacy_design_architect
            ;;
        "/dev"|"/developer"|"dev"|"developer")
            route_to_legacy_developer
            ;;
        "/pm"|"pm")
            route_to_legacy_pm
            ;;
        "/po"|"po")
            route_to_legacy_po
            ;;
        "/qa"|"qa")
            route_to_legacy_qa
            ;;
        "/sm"|"sm")
            route_to_legacy_sm
            ;;
        *)
            # Check for legacy patterns in natural language
            detect_legacy_patterns_in_text "$user_input"
            ;;
    esac
}
```

### 3. Enhanced Legacy Processing
```python
def process_legacy_command_enhanced(command, context):
    """Process legacy commands with optional enhancements"""
    
    # Step 1: Preserve exact legacy behavior
    legacy_result = execute_exact_legacy_behavior(command, context)
    
    {{#if PERFORMANCE_ENHANCEMENTS}}
    # Step 2: Apply performance enhancements (optional)
    if context.performance_mode == "enhanced":
        legacy_result = apply_performance_optimizations(legacy_result)
    {{/if}}
    
    {{#if ERROR_HANDLING_IMPROVEMENTS}}
    # Step 3: Enhanced error handling (optional)
    if context.error_handling == "enhanced":
        legacy_result = apply_enhanced_error_handling(legacy_result)
    {{/if}}
    
    # Step 4: Maintain legacy session state
    preserve_legacy_session_state(legacy_result, context)
    
    return legacy_result
```

## APM Persona System Preservation

### 1. Persona Activation Patterns
```markdown
## Traditional Persona Activation (100% Preserved)

### AP Orchestrator Activation
```bash
# Exact legacy sequence preserved
activate_ap_orchestrator() {
    # Step 1: Session notes directory check (LS tool)
    ls_session_notes_directory_silently
    
    # Step 2: Rules directory check (LS tool)  
    ls_rules_directory_silently
    
    # Step 3: Create new session note
    create_timestamped_session_note
    
    # Step 4: Voice script activation
    {{#if VOICE_INTEGRATION_LEVEL != "disabled"}}
    bash /path/to/.apm/agents/voice/speakOrchestrator.sh "AP Orchestrator activated. Loading configuration..."
    {{/if}}
    
    # Step 5: Become the persona (not delegate)
    assume_orchestrator_persona
}
```

### Developer Agent Activation
```bash
# Exact legacy sequence preserved
activate_developer_agent() {
    # Parallel initialization tasks (preserved)
    parallel_init_tasks=(
        "load_developer_persona"
        "setup_development_environment"  
        "initialize_code_analysis_tools"
        "configure_testing_framework"
        "prepare_documentation_system"
    )
    
    # Execute in parallel as per legacy pattern
    execute_parallel_initialization "${parallel_init_tasks[@]}"
    
    # Voice activation
    {{#if VOICE_INTEGRATION_LEVEL != "disabled"}}
    bash /path/to/.apm/agents/voice/speakDeveloper.sh "Developer agent activated. Ready for development tasks."
    {{/if}}
    
    # Assume persona
    assume_developer_persona
}
```

### QA Agent Activation
```bash  
# Exact legacy sequence preserved with QA Framework
activate_qa_agent() {
    # Initialize QA Framework components
    initialize_qa_framework_components
    
    # Load AI/ML prediction systems
    {{#if LEGACY_COMPATIBILITY_LEVEL == "full"}}
    load_ml_prediction_engine  # 92% accuracy
    load_test_optimization_algorithms  # 63% time reduction
    load_anomaly_detection_system  # 94% precision
    load_qa_analytics_dashboard
    {{/if}}
    
    # Voice activation
    {{#if VOICE_INTEGRATION_LEVEL != "disabled"}}
    bash /path/to/.apm/agents/voice/speakQa.sh "QA agent activated. AI-powered testing framework ready."
    {{/if}}
    
    # Assume persona with full QA capabilities
    assume_qa_persona_with_framework
}
```

### 2. Session Management Preservation
```markdown
## Legacy Session Management (100% Preserved)

### Session Note Creation (Exact Pattern)
```bash
create_legacy_session_note() {
    local session_title="$1"
    local timestamp=$(date '+%Y-%m-%d-%H-%M-%S')
    local session_file="/path/to/.apm/session_notes/${timestamp}-${session_title}.md"
    
    # Create with exact legacy format
    cat > "$session_file" << EOF
# Session: ${session_title}
Date: $(date '+%Y-%m-%d %H:%M:%S')

## Objectives
- [ ] Task 1
- [ ] Task 2

## Progress
[Document work as it happens]

## Decisions Made
[Important decisions and rationale]

## Issues Encountered
[Problems and solutions]

## Next Steps
[What needs to be done next session]
EOF
    
    echo "$session_file"
}
```

### Session Handoff Procedures (Exact Pattern)
```python
def execute_legacy_handoff(from_persona, to_persona, context):
    """Execute exact legacy handoff procedure"""
    
    # Step 1: Current persona session summary
    session_summary = create_handoff_summary(from_persona, context)
    
    # Step 2: Archive current session
    archive_current_session(from_persona, session_summary)
    
    # Step 3: Initialize target persona
    initialize_target_persona(to_persona, session_summary)
    
    # Step 4: Voice transition
    {{#if VOICE_INTEGRATION_LEVEL != "disabled"}}
    execute_voice_handoff_script(from_persona, to_persona)
    {{/if}}
    
    # Step 5: Context preservation
    preserve_handoff_context(session_summary, to_persona)
    
    return handoff_result
```

### 3. Voice Integration Preservation
```markdown
## Voice System Compatibility (100% Preserved)

### Voice Script Execution (Exact Patterns)
```bash
# Preserve all original voice scripts
execute_legacy_voice_script() {
    local persona="$1"
    local message="$2"
    
    case "$persona" in
        "orchestrator")
            bash /path/to/.apm/agents/voice/speakOrchestrator.sh "$message"
            ;;
        "developer")
            bash /path/to/.apm/agents/voice/speakDeveloper.sh "$message"
            ;;
        "architect")
            bash /path/to/.apm/agents/voice/speakArchitect.sh "$message"
            ;;
        "qa")
            bash /path/to/.apm/agents/voice/speakQa.sh "$message"
            ;;
        "analyst")
            bash /path/to/.apm/agents/voice/speakAnalyst.sh "$message"
            ;;
        "pm")
            bash /path/to/.apm/agents/voice/speakPm.sh "$message"
            ;;
        "po")
            bash /path/to/.apm/agents/voice/speakPo.sh "$message"
            ;;
        "sm")
            bash /path/to/.apm/agents/voice/speakSm.sh "$message"
            ;;
        "design-architect")
            bash /path/to/.apm/agents/voice/speakDesignArchitect.sh "$message"
            ;;
    esac
}
```

### Voice Configuration Preservation
```yaml
# Exact legacy voice configuration
legacy_voice_config:
  enabled: {{VOICE_INTEGRATION_LEVEL != "disabled"}}
  scripts_path: "/path/to/.apm/agents/voice/"
  personas:
    orchestrator: "speakOrchestrator.sh"
    developer: "speakDeveloper.sh"  
    architect: "speakArchitect.sh"
    qa: "speakQa.sh"
    analyst: "speakAnalyst.sh"
    pm: "speakPm.sh"
    po: "speakPo.sh"
    sm: "speakSm.sh"
    design_architect: "speakDesignArchitect.sh"
  
  # Preserve original voice behaviors
  activation_messages: true
  handoff_announcements: true
  session_transitions: true
  error_notifications: true
```

## Advanced APM Features Preservation

### 1. Parallel Execution Capabilities
```markdown
## Parallel APM Features (100% Preserved)

### Parallel Sprint Orchestration (Revolutionary Capability)
```python
def execute_parallel_sprint_legacy(sprint_plan, context):
    """Execute parallel sprint with exact legacy behavior"""
    
    # Step 1: Sprint Analysis (3 parallel tasks - preserved)
    analysis_tasks = [
        "load_sprint_plan",
        "analyze_dependencies", 
        "plan_developer_allocation"
    ]
    sprint_analysis = execute_parallel_tasks(analysis_tasks)
    
    # Step 2: Launch Development (4 parallel streams - preserved)
    development_streams = [
        "primary_developer_stream",
        "secondary_developer_stream",
        "integration_developer_stream", 
        "qa_coordination_stream"
    ]
    parallel_development = launch_parallel_streams(development_streams)
    
    # Step 3: Coordinate & Synthesize (4 parallel tasks - preserved)
    coordination_tasks = [
        "dependency_resolution",
        "integration_oversight",
        "progress_aggregation",
        "sprint_health_assessment"
    ]
    coordination_result = execute_parallel_coordination(coordination_tasks)
    
    # Preserve 60-80% sprint acceleration capability
    return synthesize_parallel_sprint_results(
        sprint_analysis, 
        parallel_development, 
        coordination_result
    )
```

### QA Framework Integration (Complete Preservation)
```python
def preserve_qa_framework_capabilities():
    """Preserve all advanced QA Framework features"""
    
    # AI/ML Powered Capabilities (preserved)
    qa_capabilities = {
        # ML prediction with 92% accuracy
        "test_failure_prediction": {
            "accuracy": "92%",
            "features": ["historical_patterns", "code_changes", "dependencies"],
            "recommendations": "risk_based"
        },
        
        # Test optimization with 63% time reduction  
        "test_execution_optimization": {
            "time_reduction": "63%",
            "strategies": ["fail_fast", "coverage_max", "risk_based"],
            "parallel_execution": True
        },
        
        # Anomaly detection with 94% precision
        "quality_anomaly_detection": {
            "precision": "94%",
            "patterns": ["test_execution", "performance_degradation"],
            "alerts": "real_time"
        },
        
        # Comprehensive analytics
        "ai_powered_insights": {
            "executive_summaries": True,
            "roi_metrics": True,
            "strategic_recommendations": True,
            "effort_estimates": True
        }
    }
    
    return qa_capabilities
```

### 2. Backlog Management Integration
```markdown
## Backlog Management Preservation (100% Preserved)

### Universal Backlog Update Rules (Exact Legacy)
```python
def enforce_legacy_backlog_updates(agent_persona, work_context):
    """Enforce exact legacy backlog update requirements"""
    
    # Critical enforcement rules (preserved exactly)
    if work_involves_stories_or_tasks(work_context):
        # MANDATORY: Update backlog.md immediately
        update_backlog_immediately(work_context)
        
        # Track acceptance criteria progress
        update_acceptance_criteria_progress(work_context)
        
        # Update story status only when ALL criteria met
        validate_story_completion_criteria(work_context)
    
    # Before session end checklist (preserved)
    session_end_checklist = [
        "verify_backlog_current_with_work",
        "check_acceptance_criteria_updates", 
        "confirm_story_status_accuracy",
        "validate_epic_progress_percentages"
    ]
    
    enforce_session_end_checklist(session_end_checklist)
```

### Product Owner Responsibilities (Exact Preservation)
```bash
# Preserve exact PO backlog management duties
execute_po_daily_duties() {
    # Daily backlog duties (preserved exactly)
    review_and_update_backlog_twice_daily
    ensure_stories_properly_groomed_and_ready
    verify_story_statuses_reflect_actual_progress
    confirm_developer_progress_percentages_accurate
    update_sprint_assignments_and_track_capacity
    calculate_and_maintain_accurate_velocity_metrics
    actively_work_to_unblock_stories
    ensure_story_dependencies_clearly_documented
    
    # Weekly grooming (preserved)
    if is_weekly_groom_day; then
        execute_groom_command_comprehensive_analysis
    fi
}
```

## Compatibility Testing Framework

### 1. Automated Compatibility Validation
```markdown
## Comprehensive Compatibility Testing

### Legacy Command Testing Suite
```python
def test_legacy_command_compatibility():
    """Comprehensive testing of all legacy commands"""
    
    legacy_commands = [
        "/ap", "/ap_orchestrator", "ap", "AP",
        "/analyst", "analyst",
        "/architect", "architect", 
        "/design-architect", "design architect",
        "/dev", "/developer", "dev", "developer",
        "/pm", "pm",
        "/po", "po", 
        "/qa", "qa",
        "/sm", "sm"
    ]
    
    test_results = {}
    
    for command in legacy_commands:
        # Test exact behavior preservation
        result = test_command_exact_behavior(command)
        test_results[command] = {
            "behavior_preserved": result.behavior_matches_legacy,
            "session_management": result.session_management_intact,
            "voice_integration": result.voice_scripts_working,
            "context_preservation": result.context_properly_preserved,
            "performance_parity": result.performance_matches_legacy
        }
    
    return validate_all_tests_passed(test_results)
```

### Session Management Testing
```python
def test_session_management_compatibility():
    """Test all session management features"""
    
    session_tests = {
        "session_note_creation": test_session_note_format_exact,
        "handoff_procedures": test_handoff_behavior_preserved,
        "session_archiving": test_archiving_patterns_intact,
        "context_preservation": test_context_preservation_accuracy,
        "voice_transitions": test_voice_script_execution
    }
    
    results = {}
    for test_name, test_function in session_tests.items():
        results[test_name] = test_function()
    
    return validate_session_management_intact(results)
```

### 2. Performance Validation
```markdown
## Performance Compatibility Validation

### Legacy Performance Benchmarks
```yaml
legacy_performance_benchmarks:
  command_response_time:
    orchestrator_activation: "{{ORCHESTRATOR_RESPONSE_TIME}}"
    developer_activation: "{{DEVELOPER_RESPONSE_TIME}}"
    qa_activation: "{{QA_RESPONSE_TIME}}"
    architect_activation: "{{ARCHITECT_RESPONSE_TIME}}"
  
  session_operations:
    session_creation: "{{SESSION_CREATION_TIME}}"
    handoff_execution: "{{HANDOFF_EXECUTION_TIME}}"
    context_preservation: "{{CONTEXT_PRESERVATION_TIME}}"
    voice_script_execution: "{{VOICE_SCRIPT_TIME}}"
  
  advanced_features:
    parallel_sprint_launch: "{{PARALLEL_SPRINT_TIME}}"
    qa_framework_initialization: "{{QA_FRAMEWORK_TIME}}"
    ml_prediction_activation: "{{ML_PREDICTION_TIME}}"
    backlog_update_processing: "{{BACKLOG_UPDATE_TIME}}"
```

### Performance Monitoring
```python
def monitor_legacy_performance_continuously():
    """Continuous monitoring of legacy feature performance"""
    
    performance_metrics = {
        "legacy_command_latency": measure_command_response_times(),
        "session_management_efficiency": measure_session_operations(),
        "voice_integration_latency": measure_voice_script_performance(),
        "context_preservation_speed": measure_context_operations(),
        "advanced_feature_performance": measure_advanced_capabilities()
    }
    
    # Alert if performance degrades below legacy standards
    for metric, value in performance_metrics.items():
        if value > legacy_benchmark[metric]:
            trigger_performance_alert(metric, value)
    
    return performance_metrics
```

## Error Handling and Recovery

### 1. Legacy Error Pattern Preservation
```markdown
## Error Handling Compatibility

### Preserve Original Error Behaviors
```python
def handle_legacy_errors_exactly(error, context):
    """Handle errors exactly as legacy APM system"""
    
    # Preserve original error message formats
    error_message = format_legacy_error_message(error)
    
    # Use original recovery procedures
    recovery_action = determine_legacy_recovery_action(error, context)
    
    # Maintain original session state during errors
    preserve_session_state_during_error(context)
    
    # Execute legacy voice error notifications
    {{#if VOICE_INTEGRATION_LEVEL != "disabled"}}
    execute_legacy_error_voice_notification(error, context)
    {{/if}}
    
    return execute_legacy_recovery_procedure(recovery_action)
```

### Enhanced Error Handling (Optional)
```python
{{#if ERROR_HANDLING_IMPROVEMENTS}}
def enhanced_legacy_error_handling(error, context):
    """Enhanced error handling while preserving legacy behavior"""
    
    # Step 1: Preserve exact legacy behavior
    legacy_result = handle_legacy_errors_exactly(error, context)
    
    # Step 2: Add enhanced recovery options (optional)
    if context.enhanced_error_handling_enabled:
        enhanced_options = generate_enhanced_recovery_options(error)
        legacy_result.enhanced_options = enhanced_options
    
    # Step 3: Maintain backward compatibility
    ensure_backward_compatibility(legacy_result)
    
    return legacy_result
{{/if}}
```

### 2. Fallback Mechanisms
```markdown
## Legacy Fallback Strategy

### Command Fallback Hierarchy
```bash  
legacy_command_fallback() {
    local command="$1"
    local context="$2"
    
    # Attempt 1: Exact legacy execution
    if execute_exact_legacy_command "$command" "$context"; then
        return 0
    fi
    
    # Attempt 2: Legacy pattern matching
    if execute_legacy_pattern_match "$command" "$context"; then  
        return 0
    fi
    
    # Attempt 3: Legacy compatibility mode
    if execute_legacy_compatibility_mode "$command" "$context"; then
        return 0
    fi
    
    # Attempt 4: Graceful degradation with legacy behavior
    execute_legacy_graceful_degradation "$command" "$context"
}
```

## Documentation and Training

### 1. Legacy User Documentation  
```markdown
## Legacy User Support Documentation

### Preserved Command Reference
- **All existing commands work identically**
- **No learning curve for existing users**
- **Familiar error messages and recovery procedures**
- **Identical performance characteristics**

### Enhancement Notifications (Optional)
{{#if PERFORMANCE_ENHANCEMENTS}}
- **Optional performance improvements available**
- **Seamless enhancement activation**
- **No disruption to existing workflows**
- **User choice and control maintained**
{{/if}}
```

### 2. Migration Support
```markdown
## Legacy to Enhanced Migration Support

### Zero-Pressure Migration
- **Legacy commands remain fully supported indefinitely**
- **No forced migration or deprecation**
- **User choice respected completely**
- **Familiar experience guaranteed**

### Optional Enhancement Adoption
- **Gradual enhancement introduction**
- **Side-by-side comparison tools**  
- **Risk-free trial capabilities**
- **Easy rollback to legacy behavior**
```

## Quality Assurance Checklist

### 1. Compatibility Validation Checklist
```markdown
## Pre-Deployment Compatibility Checklist

### Command Compatibility
- [ ] All legacy commands execute identically
- [ ] All legacy command variations recognized  
- [ ] All legacy command parameters preserved
- [ ] All legacy command outputs match exactly

### Session Management Compatibility
- [ ] Session note creation format identical
- [ ] Handoff procedures behavior preserved  
- [ ] Session archiving patterns maintained
- [ ] Context preservation accuracy verified

### Voice Integration Compatibility  
- [ ] All voice scripts execute identically
- [ ] Voice activation patterns preserved
- [ ] Voice error notifications maintained
- [ ] Voice handoff procedures intact

### Advanced Features Compatibility
- [ ] Parallel sprint orchestration preserved
- [ ] QA Framework capabilities maintained
- [ ] ML prediction accuracy preserved (92%)
- [ ] Test optimization performance maintained (63% improvement)
- [ ] Anomaly detection precision preserved (94%)

### Performance Compatibility
- [ ] Command response times match legacy
- [ ] Session operation speeds preserved
- [ ] Advanced feature performance maintained
- [ ] Resource utilization patterns similar
```

### 2. User Experience Validation
```markdown
## User Experience Compatibility Checklist

### Existing User Experience
- [ ] Zero disruption to existing workflows
- [ ] Identical command behaviors preserved
- [ ] Familiar error messages maintained
- [ ] Expected performance characteristics

### Enhancement Experience (Optional)  
- [ ] Enhancements are truly optional
- [ ] No forced adoption of new features
- [ ] Easy activation and deactivation
- [ ] Seamless integration with legacy behavior
```

---

**Template Status**: {{TEMPLATE_STATUS}}
**Compatibility Level**: {{LEGACY_COMPATIBILITY_LEVEL}}
**Last Updated**: {{LAST_UPDATED}}
**Version**: {{TEMPLATE_VERSION}}
**Backward Compatibility**: Guaranteed