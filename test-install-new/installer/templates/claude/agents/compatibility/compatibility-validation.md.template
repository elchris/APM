# Compatibility Validation Template

**Version**: 1.0.0  
**Component**: Compatibility Validation System  
**Purpose**: Ensure consistent behavior and results between native sub-agents and Task-based execution

## Overview

The Compatibility Validation System provides comprehensive testing and verification that ensures native sub-agents and Task-based execution produce identical results, maintain the same interfaces, and preserve all functionality during the transition period.

## Validation Architecture

```mermaid
graph TD
    A[Validation Request] --> B[Validation Controller]
    B --> C[Test Suite Manager]
    
    C --> D[Functional Tests]
    C --> E[Interface Tests]
    C --> F[Performance Tests]
    C --> G[Error Handling Tests]
    
    D --> H[Native Execution]
    D --> I[Task Execution]
    
    E --> H
    E --> I
    
    F --> H
    F --> I
    
    G --> H
    G --> I
    
    H --> J[Result Collector]
    I --> J
    
    J --> K[Comparison Engine]
    K --> L[Validation Report]
    
    L --> M{All Tests Pass?}
    M -->|Yes| N[Compatibility Confirmed]
    M -->|No| O[Issue Identification]
    
    O --> P[Remediation Suggestions]
```

## Validation Framework

### Validation Controller

```typescript
interface ValidationController {
  validateCommand(command: string, options: ValidationOptions): Promise<ValidationResult>;
  validateAllCommands(): Promise<BatchValidationResult>;
  continuousValidation(command: string): Promise<void>;
}

class CompatibilityValidator implements ValidationController {
  private testSuites: TestSuite[] = [
    new FunctionalTestSuite(),
    new InterfaceTestSuite(),
    new PerformanceTestSuite(),
    new ErrorHandlingTestSuite(),
    new EdgeCaseTestSuite()
  ];
  
  async validateCommand(
    command: string, 
    options: ValidationOptions = {}
  ): Promise<ValidationResult> {
    const results: TestSuiteResult[] = [];
    
    console.log(`üîç Starting compatibility validation for: ${command}`);
    
    // Run all test suites
    for (const suite of this.testSuites) {
      if (this.shouldRunSuite(suite, options)) {
        const result = await suite.run(command, options);
        results.push(result);
        
        // Early exit on critical failure
        if (result.critical && !result.passed) {
          break;
        }
      }
    }
    
    // Compile final result
    return this.compileValidationResult(command, results);
  }
}
```

### Test Suite Base

```typescript
abstract class TestSuite {
  abstract name: string;
  abstract critical: boolean;
  
  async run(command: string, options: ValidationOptions): Promise<TestSuiteResult> {
    const startTime = Date.now();
    const tests = await this.getTests(command, options);
    
    const results: TestResult[] = [];
    
    for (const test of tests) {
      try {
        const result = await this.runTest(test, command);
        results.push(result);
      } catch (error) {
        results.push({
          name: test.name,
          passed: false,
          error: error.message,
          critical: test.critical
        });
      }
    }
    
    return {
      suite: this.name,
      passed: results.every(r => r.passed),
      critical: this.critical,
      tests: results,
      duration: Date.now() - startTime,
      summary: this.generateSummary(results)
    };
  }
  
  protected abstract getTests(command: string, options: ValidationOptions): Promise<Test[]>;
  protected abstract runTest(test: Test, command: string): Promise<TestResult>;
}
```

## Functional Validation

### Functional Test Suite

```typescript
class FunctionalTestSuite extends TestSuite {
  name = 'Functional Compatibility';
  critical = true;
  
  protected async getTests(command: string): Promise<Test[]> {
    return [
      {
        name: 'Basic Execution',
        description: 'Verify both modes execute successfully',
        critical: true,
        execute: this.testBasicExecution.bind(this)
      },
      {
        name: 'Result Consistency',
        description: 'Verify identical output between modes',
        critical: true,
        execute: this.testResultConsistency.bind(this)
      },
      {
        name: 'Parameter Handling',
        description: 'Verify parameter processing consistency',
        critical: true,
        execute: this.testParameterHandling.bind(this)
      },
      {
        name: 'State Management',
        description: 'Verify state preservation and management',
        critical: false,
        execute: this.testStateManagement.bind(this)
      }
    ];
  }
  
  private async testBasicExecution(command: string): Promise<TestResult> {
    // Execute in both modes
    const nativeResult = await this.executeInMode(command, 'native');
    const taskResult = await this.executeInMode(command, 'task');
    
    // Check both succeeded
    const bothSucceeded = nativeResult.success && taskResult.success;
    
    return {
      name: 'Basic Execution',
      passed: bothSucceeded,
      details: {
        native: { success: nativeResult.success, error: nativeResult.error },
        task: { success: taskResult.success, error: taskResult.error }
      }
    };
  }
  
  private async testResultConsistency(command: string): Promise<TestResult> {
    // Get results from both modes
    const nativeResult = await this.executeInMode(command, 'native');
    const taskResult = await this.executeInMode(command, 'task');
    
    // Deep compare results
    const comparison = this.deepCompareResults(nativeResult, taskResult);
    
    return {
      name: 'Result Consistency',
      passed: comparison.identical,
      details: {
        differences: comparison.differences,
        similarity: comparison.similarity
      }
    };
  }
  
  private deepCompareResults(result1: any, result2: any): ComparisonResult {
    const differences: string[] = [];
    
    // Compare structure
    if (typeof result1 !== typeof result2) {
      differences.push(`Type mismatch: ${typeof result1} vs ${typeof result2}`);
    }
    
    // Compare data (if objects)
    if (typeof result1 === 'object' && typeof result2 === 'object') {
      const keys1 = Object.keys(result1 || {});
      const keys2 = Object.keys(result2 || {});
      
      // Check for missing keys
      const missingInResult2 = keys1.filter(k => !keys2.includes(k));
      const missingInResult1 = keys2.filter(k => !keys1.includes(k));
      
      differences.push(...missingInResult2.map(k => `Missing in task result: ${k}`));
      differences.push(...missingInResult1.map(k => `Missing in native result: ${k}`));
      
      // Deep compare common keys
      const commonKeys = keys1.filter(k => keys2.includes(k));
      for (const key of commonKeys) {
        const subComparison = this.deepCompareResults(result1[key], result2[key]);
        differences.push(...subComparison.differences.map(d => `${key}.${d}`));
      }
    } else if (result1 !== result2) {
      differences.push(`Value mismatch: "${result1}" vs "${result2}"`);
    }
    
    return {
      identical: differences.length === 0,
      differences,
      similarity: 1 - (differences.length / 100) // Rough similarity score
    };
  }
}
```

## Interface Validation

### Interface Test Suite

```typescript
class InterfaceTestSuite extends TestSuite {
  name = 'Interface Compatibility';
  critical = true;
  
  protected async getTests(command: string): Promise<Test[]> {
    return [
      {
        name: 'Command Interface',
        description: 'Verify command accepts same parameters',
        critical: true,
        execute: this.testCommandInterface.bind(this)
      },
      {
        name: 'Output Format',
        description: 'Verify output format consistency',
        critical: true,
        execute: this.testOutputFormat.bind(this)
      },
      {
        name: 'Error Interface',
        description: 'Verify error handling consistency',
        critical: true,
        execute: this.testErrorInterface.bind(this)
      },
      {
        name: 'Progress Reporting',
        description: 'Verify progress reporting compatibility',
        critical: false,
        execute: this.testProgressReporting.bind(this)
      }
    ];
  }
  
  private async testCommandInterface(command: string): Promise<TestResult> {
    // Test with various parameter combinations
    const parameterSets = this.generateParameterSets(command);
    const results: ParameterTestResult[] = [];
    
    for (const params of parameterSets) {
      try {
        const nativeAccepts = await this.testParameterAcceptance(command, 'native', params);
        const taskAccepts = await this.testParameterAcceptance(command, 'task', params);
        
        results.push({
          parameters: params,
          nativeAccepts,
          taskAccepts,
          consistent: nativeAccepts === taskAccepts
        });
      } catch (error) {
        results.push({
          parameters: params,
          nativeAccepts: false,
          taskAccepts: false,
          consistent: true,
          error: error.message
        });
      }
    }
    
    const allConsistent = results.every(r => r.consistent);
    
    return {
      name: 'Command Interface',
      passed: allConsistent,
      details: {
        testedParameterSets: results.length,
        inconsistencies: results.filter(r => !r.consistent)
      }
    };
  }
  
  private async testOutputFormat(command: string): Promise<TestResult> {
    const nativeOutput = await this.executeInMode(command, 'native');
    const taskOutput = await this.executeInMode(command, 'task');
    
    // Analyze output structure
    const nativeStructure = this.analyzeOutputStructure(nativeOutput);
    const taskStructure = this.analyzeOutputStructure(taskOutput);
    
    const structuresMatch = this.compareStructures(nativeStructure, taskStructure);
    
    return {
      name: 'Output Format',
      passed: structuresMatch.compatible,
      details: {
        nativeStructure,
        taskStructure,
        differences: structuresMatch.differences
      }
    };
  }
  
  private analyzeOutputStructure(output: any): OutputStructure {
    return {
      type: typeof output,
      isArray: Array.isArray(output),
      keys: typeof output === 'object' ? Object.keys(output || {}) : [],
      hasData: output?.data !== undefined,
      hasMetadata: output?.metadata !== undefined,
      hasErrors: output?.errors !== undefined
    };
  }
}
```

## Performance Validation

### Performance Test Suite

```typescript
class PerformanceTestSuite extends TestSuite {
  name = 'Performance Validation';
  critical = false;
  
  protected async getTests(command: string): Promise<Test[]> {
    return [
      {
        name: 'Execution Time',
        description: 'Compare execution times between modes',
        critical: false,
        execute: this.testExecutionTime.bind(this)
      },
      {
        name: 'Resource Usage',
        description: 'Compare resource consumption',
        critical: false,
        execute: this.testResourceUsage.bind(this)
      },
      {
        name: 'Scalability',
        description: 'Test with varying workload sizes',
        critical: false,
        execute: this.testScalability.bind(this)
      },
      {
        name: 'Concurrency',
        description: 'Test concurrent execution behavior',
        critical: false,
        execute: this.testConcurrency.bind(this)
      }
    ];
  }
  
  private async testExecutionTime(command: string): Promise<TestResult> {
    const iterations = 5;
    const nativeTimes: number[] = [];
    const taskTimes: number[] = [];
    
    // Run multiple iterations
    for (let i = 0; i < iterations; i++) {
      const nativeTime = await this.measureExecutionTime(command, 'native');
      const taskTime = await this.measureExecutionTime(command, 'task');
      
      nativeTimes.push(nativeTime);
      taskTimes.push(taskTime);
    }
    
    // Calculate statistics
    const nativeAvg = nativeTimes.reduce((a, b) => a + b, 0) / nativeTimes.length;
    const taskAvg = taskTimes.reduce((a, b) => a + b, 0) / taskTimes.length;
    const improvement = taskAvg / nativeAvg;
    
    return {
      name: 'Execution Time',
      passed: true, // Performance tests don't fail, just report
      details: {
        nativeAverage: nativeAvg,
        taskAverage: taskAvg,
        improvement: improvement,
        nativeResults: nativeTimes,
        taskResults: taskTimes
      }
    };
  }
  
  private async testScalability(command: string): Promise<TestResult> {
    const workloadSizes = [1, 3, 5, 10]; // Different parallel task counts
    const results: ScalabilityResult[] = [];
    
    for (const size of workloadSizes) {
      const nativeTime = await this.measureScalability(command, 'native', size);
      const taskTime = await this.measureScalability(command, 'task', size);
      
      results.push({
        workloadSize: size,
        nativeTime,
        taskTime,
        scalingFactor: nativeTime / taskTime
      });
    }
    
    return {
      name: 'Scalability',
      passed: true,
      details: {
        scalabilityResults: results,
        scalingTrend: this.analyzeScalingTrend(results)
      }
    };
  }
}
```

## Error Handling Validation

### Error Handling Test Suite

```typescript
class ErrorHandlingTestSuite extends TestSuite {
  name = 'Error Handling Compatibility';
  critical = true;
  
  protected async getTests(command: string): Promise<Test[]> {
    return [
      {
        name: 'Error Consistency',
        description: 'Verify both modes handle errors similarly',
        critical: true,
        execute: this.testErrorConsistency.bind(this)
      },
      {
        name: 'Error Format',
        description: 'Verify error message format consistency',
        critical: true,
        execute: this.testErrorFormat.bind(this)
      },
      {
        name: 'Recovery Behavior',
        description: 'Verify error recovery mechanisms',
        critical: false,
        execute: this.testRecoveryBehavior.bind(this)
      }
    ];
  }
  
  private async testErrorConsistency(command: string): Promise<TestResult> {
    // Test various error scenarios
    const errorScenarios = this.getErrorScenarios(command);
    const results: ErrorTestResult[] = [];
    
    for (const scenario of errorScenarios) {
      const nativeError = await this.induceError(command, 'native', scenario);
      const taskError = await this.induceError(command, 'task', scenario);
      
      results.push({
        scenario: scenario.name,
        nativeError: this.normalizeError(nativeError),
        taskError: this.normalizeError(taskError),
        consistent: this.compareErrors(nativeError, taskError)
      });
    }
    
    const allConsistent = results.every(r => r.consistent);
    
    return {
      name: 'Error Consistency',
      passed: allConsistent,
      details: {
        testedScenarios: results.length,
        inconsistentErrors: results.filter(r => !r.consistent)
      }
    };
  }
  
  private compareErrors(error1: any, error2: any): boolean {
    // Compare error types
    if (error1?.constructor?.name !== error2?.constructor?.name) {
      return false;
    }
    
    // Compare error codes (if present)
    if (error1?.code !== error2?.code) {
      return false;
    }
    
    // Compare general error categories
    const category1 = this.categorizeError(error1);
    const category2 = this.categorizeError(error2);
    
    return category1 === category2;
  }
}
```

## Edge Case Validation

### Edge Case Test Suite

```typescript
class EdgeCaseTestSuite extends TestSuite {
  name = 'Edge Case Compatibility';
  critical = false;
  
  protected async getTests(command: string): Promise<Test[]> {
    return [
      {
        name: 'Empty Input',
        description: 'Test behavior with empty inputs',
        critical: false,
        execute: this.testEmptyInput.bind(this)
      },
      {
        name: 'Large Input',
        description: 'Test behavior with large inputs',
        critical: false,
        execute: this.testLargeInput.bind(this)
      },
      {
        name: 'Malformed Input',
        description: 'Test behavior with malformed inputs',
        critical: false,
        execute: this.testMalformedInput.bind(this)
      },
      {
        name: 'Concurrent Access',
        description: 'Test concurrent command execution',
        critical: false,
        execute: this.testConcurrentAccess.bind(this)
      }
    ];
  }
}
```

## Continuous Validation

### Continuous Validation Engine

```typescript
class ContinuousValidationEngine {
  private validationSchedule: Map<string, ValidationSchedule> = new Map();
  
  async startContinuousValidation(command: string): Promise<void> {
    const schedule: ValidationSchedule = {
      command,
      interval: 24 * 60 * 60 * 1000, // 24 hours
      lastRun: null,
      failures: 0,
      enabled: true
    };
    
    this.validationSchedule.set(command, schedule);
    
    // Start validation loop
    this.scheduleValidation(command);
  }
  
  private async scheduleValidation(command: string): Promise<void> {
    const schedule = this.validationSchedule.get(command);
    if (!schedule || !schedule.enabled) return;
    
    setTimeout(async () => {
      await this.runScheduledValidation(command);
      this.scheduleValidation(command); // Reschedule
    }, schedule.interval);
  }
  
  private async runScheduledValidation(command: string): Promise<void> {
    try {
      const result = await this.validator.validateCommand(command);
      
      if (!result.passed) {
        await this.handleValidationFailure(command, result);
      } else {
        await this.handleValidationSuccess(command, result);
      }
      
      // Update schedule
      const schedule = this.validationSchedule.get(command);
      if (schedule) {
        schedule.lastRun = new Date();
        schedule.failures = result.passed ? 0 : schedule.failures + 1;
      }
      
    } catch (error) {
      console.error(`Continuous validation failed for ${command}:`, error);
    }
  }
  
  private async handleValidationFailure(
    command: string, 
    result: ValidationResult
  ): Promise<void> {
    // Log the failure
    this.logger.error('Validation failure detected', {
      command,
      failures: result.failedTests,
      timestamp: new Date()
    });
    
    // Notify relevant parties
    await this.notificationService.sendValidationAlert({
      command,
      result,
      severity: result.criticalFailures > 0 ? 'critical' : 'warning'
    });
    
    // Auto-rollback if critical
    if (result.criticalFailures > 0) {
      await this.considerAutoRollback(command);
    }
  }
}
```

## Validation Reporting

### Validation Report Generator

```typescript
class ValidationReportGenerator {
  generateReport(result: ValidationResult): ValidationReport {
    return {
      command: result.command,
      timestamp: new Date(),
      overall: result.passed ? 'PASS' : 'FAIL',
      summary: this.generateSummary(result),
      suiteResults: result.suites.map(suite => this.formatSuiteResult(suite)),
      recommendations: this.generateRecommendations(result),
      trends: this.analyzeTrends(result.command)
    };
  }
  
  formatReport(report: ValidationReport): string {
    return `
üîç Compatibility Validation Report
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Command: ${report.command}
Status: ${report.overall === 'PASS' ? '‚úÖ' : '‚ùå'} ${report.overall}
Date: ${report.timestamp.toISOString()}

üìä Summary
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total Tests: ${report.summary.totalTests}
Passed: ${report.summary.passedTests}
Failed: ${report.summary.failedTests}
Critical Failures: ${report.summary.criticalFailures}

üìã Test Suite Results
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
${report.suiteResults.map(suite => this.formatSuiteSection(suite)).join('\n')}

üí° Recommendations
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
${report.recommendations.map(rec => `‚Ä¢ ${rec}`).join('\n')}

üìà Trends
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
${this.formatTrends(report.trends)}
    `;
  }
  
  private formatSuiteSection(suite: FormattedSuiteResult): string {
    const status = suite.passed ? '‚úÖ' : '‚ùå';
    return `
${status} ${suite.name} (${suite.duration}ms)
   ${suite.tests.map(test => `${test.passed ? '‚úì' : '‚úó'} ${test.name}`).join('\n   ')}
${suite.failures.length > 0 ? `   Issues: ${suite.failures.join(', ')}` : ''}
    `;
  }
}
```

## Automated Remediation

### Issue Resolution Engine

```typescript
class ValidationIssueResolver {
  async resolveIssues(result: ValidationResult): Promise<ResolutionResult> {
    const resolutions: Resolution[] = [];
    
    for (const suite of result.suites) {
      if (!suite.passed) {
        const suiteResolution = await this.resolveSuiteIssues(suite);
        resolutions.push(...suiteResolution);
      }
    }
    
    return {
      totalIssues: resolutions.length,
      resolvedIssues: resolutions.filter(r => r.resolved).length,
      resolutions
    };
  }
  
  private async resolveSuiteIssues(suite: TestSuiteResult): Promise<Resolution[]> {
    const resolutions: Resolution[] = [];
    
    for (const test of suite.tests) {
      if (!test.passed) {
        const resolution = await this.resolveTestIssue(test);
        if (resolution) {
          resolutions.push(resolution);
        }
      }
    }
    
    return resolutions;
  }
  
  private async resolveTestIssue(test: TestResult): Promise<Resolution | null> {
    // Analyze the specific test failure
    const analysis = this.analyzeTestFailure(test);
    
    // Try to auto-resolve common issues
    switch (analysis.category) {
      case 'output_format':
        return await this.resolveOutputFormatIssue(test, analysis);
      case 'parameter_handling':
        return await this.resolveParameterIssue(test, analysis);
      case 'error_handling':
        return await this.resolveErrorHandlingIssue(test, analysis);
      default:
        return {
          test: test.name,
          resolved: false,
          reason: 'Unknown issue category',
          recommendation: 'Manual investigation required'
        };
    }
  }
}
```

## Usage Examples

### Validation Commands

```bash
# Validate single command
/validate-compatibility parallel-sprint

# Validate all commands
/validate-all-compatibility

# Run specific test suite
/validate-compatibility parallel-sprint --suite=functional

# Continuous validation
/start-continuous-validation parallel-sprint

# Generate validation report
/validation-report parallel-sprint

# Auto-resolve issues
/resolve-compatibility-issues parallel-sprint
```

### Configuration

```yaml
# .apm/config/validation.yaml
validation:
  enabled: true
  continuous: false
  
  test_suites:
    functional: true
    interface: true
    performance: true
    error_handling: true
    edge_cases: false
    
  thresholds:
    max_performance_deviation: 0.1  # 10%
    min_similarity_score: 0.95      # 95%
    max_acceptable_failures: 0
    
  reporting:
    generate_reports: true
    report_format: markdown
    include_trends: true
    
  remediation:
    auto_resolve: true
    notify_on_failure: true
    rollback_on_critical: true
```

## Summary

The Compatibility Validation System ensures:
- Comprehensive testing of all compatibility aspects
- Automated detection of inconsistencies
- Continuous monitoring of compatibility health
- Detailed reporting and trend analysis
- Automated issue resolution where possible
- Confidence in migration decisions

This provides users with complete assurance that the native sub-agent system maintains full compatibility with existing Task-based workflows.