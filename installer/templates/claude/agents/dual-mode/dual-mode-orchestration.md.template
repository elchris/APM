# Dual-Mode Orchestration System Template

## Overview
This template creates the core dual-mode coordination system that enables seamless coexistence between legacy APM commands and native Claude Code sub-agent operations.

## Configuration Variables
```yaml
# Dual-Mode Configuration
DUAL_MODE_ENABLED: {{DUAL_MODE_ENABLED}}
LEGACY_COMPATIBILITY_LEVEL: {{LEGACY_COMPATIBILITY_LEVEL}}  # full, partial, minimal
SUBAGENT_INTEGRATION_MODE: {{SUBAGENT_INTEGRATION_MODE}}    # native, hybrid, legacy-first
TRANSITION_STRATEGY: {{TRANSITION_STRATEGY}}                # gradual, immediate, user-choice
VALIDATION_DEPTH: {{VALIDATION_DEPTH}}                      # comprehensive, standard, basic
MIGRATION_TIMELINE: {{MIGRATION_TIMELINE}}                  # 30-days, 60-days, 90-days, indefinite

# Performance Settings
PARALLEL_EXECUTION_ENABLED: {{PARALLEL_EXECUTION_ENABLED}}
AUTO_MODE_DETECTION: {{AUTO_MODE_DETECTION}}
CONTEXT_PRESERVATION: {{CONTEXT_PRESERVATION}}
CROSS_MODE_HANDOFFS: {{CROSS_MODE_HANDOFFS}}
```

## Dual-Mode Architecture

### 1. Mode Detection Engine
```markdown
## Automatic Mode Detection

### Legacy APM Detection Patterns
- User input starts with `/ap`, `/dev`, `/architect`, `/qa`, etc.
- Session context contains APM persona state
- User explicitly requests APM functionality
- Legacy command syntax detected

### Native Sub-Agent Detection Patterns  
- User mentions agents in natural language ("have the developer review this")
- Claude Code sub-agent syntax detected
- Native coordination patterns identified
- Modern workflow requests

### Hybrid Mode Triggers
- Mixed command usage in session
- Cross-mode handoff requests
- Complex multi-persona workflows
- User requests for both modes
```

### 2. Command Router System
```markdown
## Intelligent Command Routing

### Legacy APM Route
When legacy commands detected:
1. **Preserve Original Behavior**: Full APM command execution
2. **Session Management**: Traditional APM session notes
3. **Voice Integration**: Original voice scripts maintained
4. **Persona Activation**: Classic persona switching
5. **Context Handling**: APM-style context preservation

### Native Sub-Agent Route  
When native operations detected:
1. **Sub-Agent Coordination**: Modern Claude Code patterns
2. **Natural Language**: Conversational agent interactions
3. **Context Flow**: Seamless information passing
4. **Task Management**: Native coordination patterns
5. **Performance**: Optimized execution paths

### Hybrid Route
When mixed usage detected:
1. **Smart Bridging**: Seamless mode transitions
2. **Context Translation**: APM â†” Native format conversion
3. **State Synchronization**: Unified context management
4. **Performance Balance**: Optimized for both modes
5. **User Experience**: Transparent operation
```

### 3. Context Management System
```markdown
## Unified Context Management

### APM Context Format
```yaml
apm_context:
  persona: "{{CURRENT_PERSONA}}"
  session_id: "{{SESSION_ID}}"
  voice_enabled: {{VOICE_ENABLED}}
  session_notes: "{{SESSION_NOTES_PATH}}"
  rules_active: {{RULES_ACTIVE}}
```

### Native Context Format
```yaml
native_context:
  active_agents: [{{ACTIVE_AGENTS}}]
  coordination_mode: "{{COORDINATION_MODE}}"
  task_queue: {{TASK_QUEUE}}
  context_flow: {{CONTEXT_FLOW}}
  performance_mode: "{{PERFORMANCE_MODE}}"
```

### Context Translation Engine
```python
def translate_apm_to_native(apm_context):
    """Convert APM context to native format"""
    return {
        'active_agents': [apm_context.persona],
        'coordination_mode': 'single-persona',
        'context_flow': apm_context.session_notes,
        'legacy_compatibility': True
    }

def translate_native_to_apm(native_context):
    """Convert native context to APM format"""
    primary_agent = native_context.active_agents[0] if native_context.active_agents else 'orchestrator'
    return {
        'persona': primary_agent,
        'session_id': generate_session_id(),
        'voice_enabled': True,
        'native_mode': True
    }
```

### 4. Performance Optimization
```markdown
## Dual-Mode Performance Strategy

### Mode-Specific Optimizations
- **Legacy APM**: Preserve original performance characteristics
- **Native Sub-Agent**: Leverage modern optimization patterns
- **Hybrid**: Dynamic optimization based on usage patterns

### Parallel Execution Support
- **APM Parallel Tasks**: Maintain existing parallel capabilities
- **Native Coordination**: Enable modern parallel patterns
- **Cross-Mode Sync**: Coordinate parallel operations across modes

### Resource Management
- **Memory Efficiency**: Shared context optimization
- **CPU Utilization**: Mode-appropriate processing
- **I/O Operations**: Unified file system access
```

## Implementation Patterns

### 1. Initialization Sequence
```markdown
## Dual-Mode Initialization

### Step 1: Mode Detection
```bash
# Detect user's preferred mode
if [[ "$USER_INPUT" =~ ^/(ap|dev|architect|qa|pm|analyst) ]]; then
    ACTIVE_MODE="legacy_apm"
    {{#if LEGACY_COMPATIBILITY_LEVEL == "full"}}
    COMPATIBILITY_FEATURES="all"
    {{/if}}
elif [[ "$USER_INPUT" =~ (developer|architect|qa).*(review|analyze|help) ]]; then
    ACTIVE_MODE="native_subagent"
    {{#if SUBAGENT_INTEGRATION_MODE == "native"}}
    OPTIMIZATION_LEVEL="maximum"
    {{/if}}
else
    ACTIVE_MODE="auto_detect"
fi
```

### Step 2: Context Setup
```bash
# Initialize appropriate context
case $ACTIVE_MODE in
    "legacy_apm")
        setup_apm_context
        load_apm_session_management  
        enable_apm_voice_systems
        ;;
    "native_subagent")
        setup_native_context
        enable_subagent_coordination
        optimize_performance_mode
        ;;
    "auto_detect")
        setup_hybrid_context
        enable_dynamic_switching
        ;;
esac
```

### Step 3: Feature Activation
```bash
# Activate mode-specific features
{{#if DUAL_MODE_ENABLED}}
activate_dual_mode_features() {
    # Legacy APM Features
    {{#if LEGACY_COMPATIBILITY_LEVEL != "minimal"}}
    enable_apm_personas
    enable_apm_session_notes
    enable_apm_voice_integration
    {{/if}}
    
    # Native Sub-Agent Features  
    {{#if SUBAGENT_INTEGRATION_MODE != "legacy-first"}}
    enable_native_coordination
    enable_natural_language_processing
    enable_modern_task_management
    {{/if}}
    
    # Cross-Mode Features
    enable_context_translation
    enable_seamless_handoffs
    enable_unified_performance_monitoring
}
{{/if}}
```

### 2. Command Processing Pipeline
```markdown
## Dual-Mode Command Processing

### Legacy APM Pipeline
```python
def process_apm_command(command, context):
    """Process legacy APM commands with full compatibility"""
    
    # Step 1: Validate APM command
    if not validate_apm_syntax(command):
        return fallback_to_native(command, context)
    
    # Step 2: Setup APM environment
    apm_env = setup_apm_environment(context)
    
    # Step 3: Execute with APM patterns
    result = execute_apm_command(command, apm_env)
    
    # Step 4: Maintain APM state
    update_apm_session_state(result, apm_env)
    
    return result
```

### Native Sub-Agent Pipeline
```python
def process_native_command(command, context):
    """Process native sub-agent commands with modern patterns"""
    
    # Step 1: Parse natural language intent
    intent = parse_agent_intent(command)
    
    # Step 2: Coordinate sub-agents
    agents = identify_required_agents(intent)
    
    # Step 3: Execute with modern patterns
    result = coordinate_subagents(agents, intent, context)
    
    # Step 4: Optimize performance
    optimize_execution_path(result)
    
    return result
```

### Hybrid Pipeline
```python
def process_hybrid_command(command, context):
    """Process commands requiring both modes"""
    
    # Step 1: Analyze command complexity
    complexity = analyze_command_complexity(command)
    
    # Step 2: Plan execution strategy
    if complexity.requires_apm and complexity.requires_native:
        strategy = plan_hybrid_execution(command, context)
        return execute_hybrid_strategy(strategy)
    else:
        return route_to_appropriate_mode(command, context)
```

## Migration Support

### 1. Gradual Transition Framework
```markdown
## User Migration Strategy

### Phase 1: Introduction ({{MIGRATION_TIMELINE}} * 0.2)
- **Dual-mode availability announcement**
- **Optional native sub-agent trials**  
- **Side-by-side comparison tools**
- **User preference detection**

### Phase 2: Education ({{MIGRATION_TIMELINE}} * 0.4)  
- **Interactive tutorials for native mode**
- **Performance benefit demonstrations**
- **Migration assistance tools**
- **Hybrid workflow examples**

### Phase 3: Transition ({{MIGRATION_TIMELINE}} * 0.3)
- **Gradual native mode suggestions**
- **Legacy mode maintenance with notifications**
- **Advanced hybrid capabilities**
- **User choice respect and support**

### Phase 4: Stabilization ({{MIGRATION_TIMELINE}} * 0.1)
- **Full dual-mode maturity**
- **Optimized performance across modes**
- **Complete feature parity**
- **Long-term compatibility guarantee**
```

### 2. Training and Support
```markdown
## User Training Framework

### Legacy User Support
- **Preserve all existing workflows**
- **Maintain familiar command patterns**
- **Optional enhancement notifications**
- **Seamless experience guarantee**

### Native Mode Training
- **Interactive learning modules**
- **Hands-on practice environments**
- **Performance benefit showcases**
- **Advanced workflow demonstrations**

### Hybrid Mode Mastery
- **Best-of-both-worlds tutorials**
- **Complex workflow orchestration**
- **Cross-mode optimization techniques**
- **Power user advanced patterns**
```

## Quality Assurance

### 1. Compatibility Testing
```markdown
## Comprehensive Compatibility Validation

### Legacy APM Testing
- **All existing commands function identically**
- **Session management preservation**
- **Voice integration maintenance**  
- **Performance parity guarantee**

### Native Sub-Agent Testing
- **Modern coordination patterns**
- **Natural language processing accuracy**
- **Performance optimization validation**
- **Advanced feature functionality**

### Cross-Mode Testing
- **Seamless transition validation**
- **Context preservation accuracy**
- **Performance consistency**
- **User experience continuity**
```

### 2. Performance Monitoring
```markdown
## Dual-Mode Performance Metrics

### Legacy Mode Performance
```yaml
legacy_metrics:
  command_response_time: "{{LEGACY_RESPONSE_TIME}}"
  session_initialization: "{{LEGACY_INIT_TIME}}"
  voice_integration_latency: "{{VOICE_LATENCY}}"
  context_preservation_accuracy: "{{CONTEXT_ACCURACY}}"
```

### Native Mode Performance  
```yaml
native_metrics:
  coordination_efficiency: "{{COORDINATION_EFFICIENCY}}"
  natural_language_processing: "{{NLP_PERFORMANCE}}"
  parallel_execution_speedup: "{{PARALLEL_SPEEDUP}}"
  resource_optimization: "{{RESOURCE_EFFICIENCY}}"
```

### Hybrid Mode Performance
```yaml
hybrid_metrics:
  mode_transition_time: "{{TRANSITION_TIME}}"
  context_translation_accuracy: "{{TRANSLATION_ACCURACY}}"
  cross_mode_coordination: "{{CROSS_MODE_EFFICIENCY}}"
  unified_performance_index: "{{UNIFIED_PERFORMANCE}}"
```

## Error Handling and Recovery

### 1. Mode-Specific Error Handling
```markdown
## Robust Error Recovery System

### Legacy APM Error Recovery
- **Preserve original APM error patterns**
- **Maintain familiar error messages**
- **Classic recovery procedures**
- **Session state protection**

### Native Sub-Agent Error Recovery
- **Modern error handling patterns** 
- **Intelligent error recovery**
- **Context-aware error messages**
- **Advanced recovery strategies**

### Cross-Mode Error Recovery
- **Mode transition error protection**
- **Context preservation during errors**
- **Graceful degradation strategies**
- **User experience protection**
```

### 2. Fallback Mechanisms
```markdown
## Comprehensive Fallback Strategy

### Primary Fallbacks
1. **Native â†’ Legacy**: When native mode fails, gracefully fallback to APM
2. **Legacy â†’ Native**: When APM mode fails, offer native alternative
3. **Hybrid â†’ Single**: When hybrid mode fails, fallback to single mode
4. **All â†’ Basic**: When all modes fail, provide basic functionality

### Recovery Procedures
```bash
# Dual-mode recovery function
recover_dual_mode() {
    local failed_mode="$1"
    local context="$2"
    
    case "$failed_mode" in
        "native")
            echo "Falling back to legacy APM mode..."
            initialize_apm_mode "$context"
            ;;
        "legacy")
            echo "Switching to native sub-agent mode..."
            initialize_native_mode "$context"
            ;;
        "hybrid")
            echo "Simplifying to single mode..."
            select_best_single_mode "$context"
            ;;
        *)
            echo "Activating basic functionality..."
            initialize_basic_mode
            ;;
    esac
}
```

## Security and Privacy

### 1. Dual-Mode Security Framework
```markdown
## Security Considerations

### Legacy APM Security
- **Maintain existing security models**
- **Preserve authentication patterns**
- **Classic permission structures**
- **Known security boundaries**

### Native Sub-Agent Security
- **Modern security frameworks**
- **Enhanced authentication**
- **Advanced permission models**
- **Improved security boundaries**

### Cross-Mode Security
- **Unified security policies**
- **Context security preservation**
- **Mode transition security**
- **Integrated threat protection**
```

### 2. Privacy Protection
```markdown
## Privacy Framework

### Data Handling
- **Mode-specific data policies**
- **Context information protection**
- **Cross-mode data security**
- **User privacy preferences**

### Information Isolation
- **Mode-specific information boundaries**
- **Secure context translation**
- **Privacy-preserving handoffs**
- **User data protection guarantee**
```

## Future Extensibility

### 1. Evolution Framework
```markdown
## Future Development Strategy

### Planned Enhancements
- **Advanced AI/ML integration**
- **Enhanced performance optimization**
- **Extended persona capabilities**
- **Improved user experience**

### Extensibility Points
- **Plugin architecture for new modes**
- **API framework for external integration**
- **Customization framework for user preferences**
- **Evolution pathway for future technologies**
```

### 2. Compatibility Guarantee
```markdown
## Long-Term Compatibility Promise

### Legacy Support Commitment
- **Indefinite APM command support**
- **Backward compatibility guarantee**
- **Performance maintenance promise**
- **Feature preservation commitment**

### Forward Compatibility
- **Native mode evolution support**
- **Future enhancement integration**
- **Seamless upgrade pathways**
- **Continuous improvement framework**
```

---

**Template Status**: {{TEMPLATE_STATUS}}
**Last Updated**: {{LAST_UPDATED}}
**Version**: {{TEMPLATE_VERSION}}
**Dual-Mode Support**: {{DUAL_MODE_ENABLED}}